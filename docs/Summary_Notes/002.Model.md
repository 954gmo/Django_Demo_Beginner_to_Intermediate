# key concepts
ORM( Object-Relational Mapping)

- [Introduction to Django's Model](#Model)
- [Creating model, adding to the database](#Creating-Model-and-Installing-it-to-the-database)
- [Basic Data Access: CRUD](#Basic-Data-Access-CRUD-Create-Read-Update-Delete)
- [Creating Relationships](#Creating-Relationships)
- [Working with Related Objects](#Working-with-Related-Objects)
- [Accessing Foreign key Values](#Accessing-Foreign-Key-Values)
- [Accessing Many-to-Many Values](#Accessing Many-to-Many Values)

# Model
> In Django`model` is the object mapped to the database. 
> 
> It is a description of the data in your database, represented as Python code. 
> 
> When you create a `model`, Django executes SQL to create a corresponding `table` in the database 
> 
> you can use tables to map out data structures
> `Field Name, Field Description, Data Type`

> 
> it's your data layout - the equivalent of your SQL `CREATE TABLE` statements
> 
> Django uses model to execute SQL code behind the scenes and return convenient python data structures representing the rows in your database tables. 
> 
> each model is represented by a Python class that is subclass of `django.db.models.Model`
> 
> the `Model` class contains all the machinary necessary to make these objects capable of interacting with a database, which leaves our models responsible solely for defining their fields, 
> 
> each model generally corresponds to a single database table, and each attribute on a model generally corresponds to a column in that database table. 
> 
> the exception to the one-class-per-database-table is the case of many-to-many relationships. 
> 
> table names are automatically generated by combining the name of the app and the lowercase name of the model, this behavior can be override
>
# Creating Model and Installing it to the database, 
### REF
- [A complete reference to all the model fields and options](https://docs.djangoproject.com/en/dev/ref/models/fields/)
- [databases](https://docs.djangoproject.com/en/4.1/ref/databases/)
- [models relations](https://docs.djangoproject.com/en/dev/ref/models/relations/)

```python
# <app>/models.py
from django.db import models 

# DEFINITION of model, each Django model must inherit from Django's Model class
# Each of model fields has a related Django field type and field options
class TABLE_NAME(models.Model):
    Field_1 = models.CharField()
    Field_2 = models.DateTimeField()
    
    def __str__(self):
        return self.Field_1

```
```shell
# adding it to the database
# you can see Django's <app>_<model> naming convention work in the table name 
python manage.py check
python manage.py makemigrations <app>
python manage.py migrate

# check the SQL generated
python manage.py sqlmigrate <app_label> <migration_name>
```

# Basic Data Access CRUD Create Read Update Delete
```shell
# Django Interactive shell
python manage.py shell
```
```python
#
# CREATE Database RECORDS
#

from <app>.models import TABLE_NAME
obj = TABLE_NAME(field_1='some value match field1 type', filed_2='some value match field2 type')
obj.save() # Django doesn't hit the database until you explicitly tell Django to save the object. 
           # because database access is expensive time-wise.
#
# or CREATE and SAVE a record in one step.
#
TABLE_NAME.objects.create(field_1='some value match field1 type', filed_2='some value match field2 type')
# for datetimefield, need to timezone-aware
from datetime import datetime, timezone
dt = datetime(year=1999, month=12, day=3,tzinfo=timezone.utc)

#
# RETRIEVE RECORDS
#

# Retrieve all
obj_list = TABLE_NAME.objects.all()
# or 
obj_list = TABLE_NAME.objects.filter()

# Retrieve Single Record
#
# the get method only works for single objects, 
# if your search term returns multiple records, you will get an error
# if you try to retrieve a record that doesn't exist, Django will throw a DoesNotExist error
obj = TABLE_NAME.objects.get(field1='some value match field1 type')

# Retrieve Multiple Records
#  
# filter() allows you to filter your data to return zero or more records
# Django translates the search terms into an SQL WHERE clause
TABLE_NAME.objects.filter(field1='some value match fields type')
# By default, filter() uses exact match lookups, for more control, you can search using Django's field lookups 
# Note there is a double underscore between name and contains
# if the searching string doesn't match, filter() will return an empty QuerySEt
TABLE_NAME.objects.filter(field_1__contains='lskdjf', field2='some value')

#
# ORDERING DATA 
#
# internally, Django translates the order_by() into an SQL ORDER BY statement
TABLE_NAME.objects.order_by('-field') # sort in descending order
TABLE_NAME.objects.order_by('field') # sort in ascending order
TABLE_NAME.objects.order_by('field1', 'field2') # order by multiple field
TABLE_NAME.objects.filter(field='lksdf').order_by('field') # chaining lookup

#
# SLICING DATA 
#
# return a fixed number of rows from the database 
TABLE_NAME.objects.filter(field='jklsd')[0]
TABLE_NAME.objects.filter(field='ksdjf')[2:4]
# negative indexing is not allowed, but can get around by using a reverse sort:
TABLE_NAME.objects.filter(field='lkfsjd').order_by('-field')[0]

#
# UPDATE RECORD 
#
# this method of updating a database record is simple
# but inefficient as it will save all the field values, not just the field changed
var = TABLE_NAME.object.get(field='lsdkj')
var.<field> = 'value'
var.save()
# or
var.save(update_fields='field')
# use update(), it returns the number of records updated.
TABLE_NAME.objects.filter(field='sdf').update(field1='skdjfl')

#
# DELETE RECORDS
#
# delete() return a lists the total number of records affected, 
# a dictionary listing the tables affected by the delete operations, and the number of records deleted in each table 
TABLE_NAME.objects.filter(field_1__contains='test').delete()
TABLE_NAME.objects.all
```

# Creating Relationships
> Normalization
> 
> one-to-many, many-to-one, many-to-many,
> 
> after adding new models that are related, 
> make sure to delete the records from the old table, 
> otherwise, will fail as the old
> records will violate the constraints.
> 
> order of the models in the models.py file matters


```python
from django.db import models
models.ForeignKey
models.ManyToManyField
```

# Working with Related Objects
> Because of the bi-directional nature of database relationships, 
> and the need to maintain referential integrity, the basic
> database actions work differently with related objects.
> 
## Accessing Foreign Key Values
> Due to the relationship created between the `table_1` and `table_2`, 
> when you access the ForeignKey field from an instance of `table_1`, 
> Django returns an instance of the related `table_2` object
> 
> When accessing from `table_2`, we need to use Django's <object>_set() method.
> 
> `<table_2 object>.<table_1>_set.all()`
> 

## Accessing Many-to-Many Values
> works the same as accessing foreign keys, except Django returns a QuerySet, not a model instance 
> 
> When we added the ManyToManyField to `table_1` model, a special model manager class called `RelatedManager` becomes available.
> `RelatedManager` has a few useful methods, such as add()